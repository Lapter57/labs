#include <omp.h>

#include <iostream>

#define N 20

using namespace std;

int main(int argc, char** argv) {
    double a[N], b[N];
    a[0] = 0;
    /**
     * Опцию "nowait" согласно документации нельзя использовать вместе с
     * директивой "parallel for".
     */
#pragma omp parallel for  // nowait
    for (int i = 1; i < N; i++) {
        // a[i] = a[i - 1] + 2.0;
        // b[i] = a[i] + a[i - 1];
        /**
         * Чтобы не было "гонок", нужно изменить вычисление элементов массива
         * a и элементов массива b так, чтобы элементы массива a не участвовали
         * в вычислениях. Решение: можно заметить, что элементы обоих массивов
         * можно вычислить, зная только номер итерации. Это уберет зависимость
         * того, какой именно поток, какую итерацию параллельного цикла
         * выполнит.
         */
        a[i] = i * 2.0;
        b[i] = (2 * i - 1) * 2.0;
    }
    /**
     * В конце параллельного цикла происходит неявная барьерная синхронизация
     * параллельно работающих потоков, поэтому следующую строчку можно оставить
     * как есть, но также справедлива замена на b[0] = (N-1) * 2.0
     */
    b[0] = a[N - 1];
    for (int i = 0; i < N; i++) {
        cout << b[i] << " ";
    }
    cout << endl;
    return 0;
}
