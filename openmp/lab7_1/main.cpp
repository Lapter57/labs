#include <omp.h>

#include <iostream>

#define N 20

using namespace std;

int main(int argc, char** argv) {
    double a[N], b[N];
    a[0] = 0;
    /* Опцию "nowait" согласно документации нельзя использовать вместе с
       директивой "parallel for". */
#pragma omp parallel for  // nowait
    for (int i = 1; i < N; i++) {
        // a[i] = a[i - 1] + 2.0;
        // b[i] = a[i] + a[i - 1];
        /* Чтобы не было "гонок", нужно изменить вычисление элементов массива
           a и элементов массива b так, чтобы элементы массива a не участвовали
           в вычислениях. Решение: можно заметить, что элементы обоих массивов
           можно вычислить, зная только номер итерации. Это уберет зависимость
           того, какой именно поток, какую итерацию параллельного цикла
           выполнит. */
        a[i] = i * 2.0;
        b[i] = (2 * i - 1) * 2.0;
    }
    /* В конце параллельного цикла происходит неявная барьерная синхронизация
       параллельно работающих потоков, поэтому следующую строчку можно оставить
       как есть, но также справедлива замена на b[0] = (N-1) * 2.0 */
    b[0] = a[N - 1];
    for (int i = 0; i < N; i++) {
        cout << b[i] << " ";
    }
    cout << endl;
    return 0;
}
